"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var lodash_1 = require("lodash");
var shallowequal_1 = tslib_1.__importDefault(require("shallowequal"));
var cache_key_maps_1 = require("./cache-key-maps");
var CacheKeyResolver = /** @class */ (function () {
    function CacheKeyResolver(options) {
        this._lastId = 0;
        this._map = { maps: [] };
        this._usedMaps = [];
        this._options = tslib_1.__assign({ isEqual: shallowequal_1.default, maxSize: 0, onExpire: lodash_1.noop }, options);
    }
    CacheKeyResolver.prototype.getKey = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var result = this._resolveMap.apply(this, args);
        var index = result.index, parentMap = result.parentMap;
        var map = result.map;
        if (map && map.cacheKey) {
            map.usedCount++;
        }
        else {
            map = this._generateMap(parentMap, args.slice(index));
        }
        // Keep track of the least used map so we can remove it if the size of
        // the stack exceeds the maximum size.
        this._removeLeastUsedMap(map);
        return map.cacheKey;
    };
    CacheKeyResolver.prototype.getUsedCount = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var map = this._resolveMap.apply(this, args).map;
        return map ? map.usedCount : 0;
    };
    CacheKeyResolver.prototype._resolveMap = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var index = 0;
        var parentMap = this._map;
        // Traverse the tree to find the linked list of maps that match the
        // arguments of the call. Each intermediate or terminal map contains a
        // value that could be used to match with the arguments. The last map in
        // the list (the terminal) should contain a cache key. If it can does
        // not exist, we will return a falsy value so that the caller could
        // handle and generate a new cache key.
        while (parentMap.maps.length) {
            var isMatched = false;
            for (var mapIndex = 0; mapIndex < parentMap.maps.length; mapIndex++) {
                var map = parentMap.maps[mapIndex];
                if (!this._options.isEqual(map.value, args[index])) {
                    continue;
                }
                // Move the most recently used map to the top of the stack for
                // quicker access
                (_a = parentMap.maps).unshift.apply(_a, parentMap.maps.splice(mapIndex, 1));
                if ((args.length === 0 || index === args.length - 1) && cache_key_maps_1.isTerminalCacheKeyMap(map)) {
                    return { index: index, map: map, parentMap: parentMap };
                }
                isMatched = true;
                parentMap = map;
                index++;
                break;
            }
            if (!isMatched) {
                break;
            }
        }
        return { index: index, parentMap: parentMap };
    };
    CacheKeyResolver.prototype._generateMap = function (parent, args) {
        var index = 0;
        var parentMap = parent;
        var map;
        do {
            map = {
                maps: [],
                parentMap: parentMap,
                usedCount: 1,
                value: args[index],
            };
            // Continue to build the tree of maps so that it could be resolved
            // next time when the function is called with the same set of
            // arguments.
            parentMap.maps.unshift(map);
            parentMap = map;
            index++;
        } while (index < args.length);
        var terminalMap = map;
        terminalMap.cacheKey = "" + ++this._lastId;
        return terminalMap;
    };
    CacheKeyResolver.prototype._removeLeastUsedMap = function (recentlyUsedMap) {
        if (!this._options.maxSize) {
            return;
        }
        var index = this._usedMaps.indexOf(recentlyUsedMap);
        this._usedMaps.splice(index === -1 ? 0 : index, index === -1 ? 0 : 1, recentlyUsedMap);
        if (this._usedMaps.length <= this._options.maxSize) {
            return;
        }
        var map = this._usedMaps.pop();
        if (!map) {
            return;
        }
        this._removeMap(map);
        this._options.onExpire(map.cacheKey);
    };
    CacheKeyResolver.prototype._removeMap = function (map) {
        if (!map.parentMap) {
            return;
        }
        map.parentMap.maps.splice(map.parentMap.maps.indexOf(map), 1);
        if (cache_key_maps_1.isRootCacheKeyMap(map.parentMap)) {
            return;
        }
        this._removeMap(map.parentMap);
    };
    return CacheKeyResolver;
}());
exports.default = CacheKeyResolver;
//# sourceMappingURL=cache-key-resolver.js.map