{"version":3,"file":"cache-key-resolver.js","sourceRoot":"","sources":["../src/cache-key-resolver.ts"],"names":[],"mappings":"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","sourcesContent":["import { noop } from 'lodash';\nimport shallowEqual from 'shallowequal';\n\nimport {\n    isRootCacheKeyMap,\n    isTerminalCacheKeyMap,\n    ChildCacheKeyMap,\n    IntermediateCacheKeyMap,\n    RootCacheKeyMap,\n    TerminalCacheKeyMap\n} from './cache-key-maps';\n\nexport interface CacheKeyResolverOptions {\n    maxSize?: number;\n    onExpire?(key: string): void;\n    isEqual?(valueA: any, valueB: any): boolean;\n}\n\ninterface ResolveResult {\n    index: number;\n    parentMap: RootCacheKeyMap | IntermediateCacheKeyMap;\n    map?: TerminalCacheKeyMap;\n}\n\nexport default class CacheKeyResolver {\n    private _lastId = 0;\n    private _map: RootCacheKeyMap = { maps: [] };\n    private _usedMaps: TerminalCacheKeyMap[] = [];\n    private _options: Required<CacheKeyResolverOptions>;\n\n    constructor(options?: CacheKeyResolverOptions) {\n        this._options = {\n            isEqual: shallowEqual,\n            maxSize: 0,\n            onExpire: noop,\n            ...options,\n        };\n    }\n\n    getKey(...args: any[]): string {\n        const result = this._resolveMap(...args);\n        const { index, parentMap } = result;\n        let { map } = result;\n\n        if (map && map.cacheKey) {\n            map.usedCount++;\n        } else {\n            map = this._generateMap(parentMap, args.slice(index));\n        }\n\n        // Keep track of the least used map so we can remove it if the size of\n        // the stack exceeds the maximum size.\n        this._removeLeastUsedMap(map);\n\n        return map.cacheKey;\n    }\n\n    getUsedCount(...args: any[]): number {\n        const { map } = this._resolveMap(...args);\n\n        return map ? map.usedCount : 0;\n    }\n\n    private _resolveMap(...args: any[]): ResolveResult {\n        let index = 0;\n        let parentMap = this._map;\n\n        // Traverse the tree to find the linked list of maps that match the\n        // arguments of the call. Each intermediate or terminal map contains a\n        // value that could be used to match with the arguments. The last map in\n        // the list (the terminal) should contain a cache key. If it can does\n        // not exist, we will return a falsy value so that the caller could\n        // handle and generate a new cache key.\n        while (parentMap.maps.length) {\n            let isMatched = false;\n\n            for (let mapIndex = 0; mapIndex < parentMap.maps.length; mapIndex++) {\n                const map = parentMap.maps[mapIndex];\n\n                if (!this._options.isEqual(map.value, args[index])) {\n                    continue;\n                }\n\n                // Move the most recently used map to the top of the stack for\n                // quicker access\n                parentMap.maps.unshift(...parentMap.maps.splice(mapIndex, 1));\n\n                if ((args.length === 0 || index === args.length - 1) && isTerminalCacheKeyMap(map)) {\n                    return { index, map, parentMap };\n                }\n\n                isMatched = true;\n                parentMap = map;\n                index++;\n\n                break;\n            }\n\n            if (!isMatched) {\n                break;\n            }\n        }\n\n        return { index, parentMap };\n    }\n\n    private _generateMap(parent: RootCacheKeyMap | IntermediateCacheKeyMap, args: any[]): TerminalCacheKeyMap {\n        let index = 0;\n        let parentMap = parent;\n        let map: IntermediateCacheKeyMap;\n\n        do {\n            map = {\n                maps: [],\n                parentMap,\n                usedCount: 1,\n                value: args[index],\n            };\n\n            // Continue to build the tree of maps so that it could be resolved\n            // next time when the function is called with the same set of\n            // arguments.\n            parentMap.maps.unshift(map);\n\n            parentMap = map;\n            index++;\n        } while (index < args.length);\n\n        const terminalMap = map as TerminalCacheKeyMap;\n\n        terminalMap.cacheKey = `${++this._lastId}`;\n\n        return terminalMap;\n    }\n\n    private _removeLeastUsedMap(recentlyUsedMap: TerminalCacheKeyMap): void {\n        if (!this._options.maxSize) {\n            return;\n        }\n\n        const index = this._usedMaps.indexOf(recentlyUsedMap);\n\n        this._usedMaps.splice(\n            index === -1 ? 0 : index,\n            index === -1 ? 0 : 1,\n            recentlyUsedMap\n        );\n\n        if (this._usedMaps.length <= this._options.maxSize) {\n            return;\n        }\n\n        const map = this._usedMaps.pop();\n\n        if (!map) {\n            return;\n        }\n\n        this._removeMap(map);\n        this._options.onExpire(map.cacheKey);\n    }\n\n    private _removeMap(map: ChildCacheKeyMap): void {\n        if (!map.parentMap) {\n            return;\n        }\n\n        map.parentMap.maps.splice(map.parentMap.maps.indexOf(map), 1);\n\n        if (isRootCacheKeyMap(map.parentMap)) {\n            return;\n        }\n\n        this._removeMap(map.parentMap);\n    }\n}\n"]}