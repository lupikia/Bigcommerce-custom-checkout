"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_key_resolver_1 = tslib_1.__importDefault(require("./cache-key-resolver"));
describe('CacheKeyResolver', function () {
    it('returns same cache key if params are equal', function () {
        var resolver = new cache_key_resolver_1.default();
        expect(resolver.getKey('hello')).toEqual('1');
        expect(resolver.getKey('bye')).toEqual('2');
        expect(resolver.getKey('hello')).toEqual('1');
        expect(resolver.getKey('bye')).toEqual('2');
    });
    it('returns same cache key if multiple params are equal', function () {
        var resolver = new cache_key_resolver_1.default();
        expect(resolver.getKey('hello', 'world')).toEqual('1');
        expect(resolver.getKey('hello', 'good', 'bye')).toEqual('2');
        expect(resolver.getKey('hello', 'world')).toEqual('1');
        expect(resolver.getKey('hello', 'good', 'bye')).toEqual('2');
    });
    it('returns same cache key if no params are provided', function () {
        var resolver = new cache_key_resolver_1.default();
        expect(resolver.getKey()).toEqual('1');
        expect(resolver.getKey()).toEqual('1');
    });
    it('works with non-primitive params', function () {
        var resolver = new cache_key_resolver_1.default();
        var personA = { name: 'Foo' };
        var personB = { name: 'Bar' };
        var personC = { name: 'Foobar' };
        expect(resolver.getKey(personA, personB)).toEqual('1');
        expect(resolver.getKey(personB, personA)).toEqual('2');
        expect(resolver.getKey(personA, personB)).toEqual('1');
        expect(resolver.getKey(personB, personA, personC)).toEqual('3');
    });
    it('works with functions', function () {
        var resolver = new cache_key_resolver_1.default();
        var functionA = function () { return 'a'; };
        var functionB = function () { return 'b'; };
        expect(resolver.getKey('foobar', functionA)).toEqual('1');
        expect(resolver.getKey('foobar', functionB)).toEqual('2');
        expect(resolver.getKey('foobar', functionA)).toEqual('1');
        expect(resolver.getKey('foobar', functionB)).toEqual('2');
    });
    it('works with unserializable objects with cyclical reference', function () {
        var resolver = new cache_key_resolver_1.default();
        var objectB = { child: undefined };
        var objectA = { child: objectB };
        objectB.child = objectA;
        expect(resolver.getKey(objectA, objectB)).toEqual('1');
        expect(resolver.getKey(objectA, objectB)).toEqual('1');
    });
    it('returns same key if objects are shallowly equivalent', function () {
        var resolver = new cache_key_resolver_1.default();
        var objectA = { id: 1 };
        var objectB = { id: 1 };
        expect(resolver.getKey('foobar', objectA)).toEqual(resolver.getKey('foobar', objectB));
    });
    it('returns different cache key for least recently used set of arguments', function () {
        var resolver = new cache_key_resolver_1.default({ maxSize: 2 });
        expect(resolver.getKey('hello', 'world')).toEqual('1');
        // This will return the cache key
        expect(resolver.getKey('hello', 'world')).toEqual('1');
        expect(resolver.getKey('hello', 'good')).toEqual('2');
        expect(resolver.getKey('bad', 'guys')).toEqual('3');
        // This will return a new cache key because the set of arguments is
        // least recently used and the number of cache keys already exceed the
        // maximum size
        expect(resolver.getKey('hello', 'world')).toEqual('4');
    });
    it('only expires cache key if number of unique calls exceeds limit', function () {
        var resolver = new cache_key_resolver_1.default({ maxSize: 2 });
        expect(resolver.getKey('hello', 'world')).toEqual('1');
        expect(resolver.getKey('hello', 'world')).toEqual('1');
        // The previous call should not expire the key because it is called with
        // the same set of arguments
        expect(resolver.getKey('hello', 'world')).toEqual('1');
        expect(resolver.getKey('foo', 'bar')).toEqual('2');
        expect(resolver.getKey('hello', 'bye')).toEqual('3');
        // This call should return a new key because the previous two calls are
        // made with different sets of arguments
        expect(resolver.getKey('hello', 'world')).toEqual('4');
    });
    it('returns cache key used count', function () {
        var resolver = new cache_key_resolver_1.default();
        expect(resolver.getUsedCount('hello', 'world')).toEqual(0);
        resolver.getKey('hello', 'world');
        expect(resolver.getUsedCount('hello', 'world')).toEqual(1);
        resolver.getKey('hello', 'world');
        expect(resolver.getUsedCount('hello', 'world')).toEqual(2);
    });
});
//# sourceMappingURL=cache-key-resolver.spec.js.map